"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
}
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const process_1 = __importDefault(require("process"));
const child_process_1 = __importDefault(require("child_process"));
const download_1 = require("./download");
const bin = {
    initdb: path_1.default.join(__dirname, 'pgsql', 'bin', 'initdb'),
    postgres: path_1.default.join(__dirname, 'pgsql', 'bin', 'postgres'),
    psql: path_1.default.join(__dirname, 'pgsql', 'bin', 'psql'),
    createdb: path_1.default.join(__dirname, 'pgsql', 'bin', 'createdb')
};
exports.configDefaults = {
    pipe: false,
    fsync: 'off',
    pgdata: process_1.default.env.PGDATA || 'var/postgres',
    port: process_1.default.env.PGPORT || '8432',
    initSql: []
};
function start(userConfig) {
    return __awaiter(this, void 0, void 0, function* () {
        var config = Object.assign({}, exports.configDefaults, (userConfig || {}));
        yield download_1.ensureHaveBinaries(__dirname);
        var isNew = yield ensureInitDb(config.pgdata);
        var proc = yield startServer(config);
        if (isNew) {
            try {
                yield runInitSql(config);
            }
            catch (e) {
                proc.kill();
                throw e;
            }
        }
        return proc;
    });
}
function startServer(config) {
    return new Promise((resolve, reject) => {
        var p = child_process_1.default.spawn(bin.postgres, ['-D', config.pgdata, '-c', 'fsync=' + config.fsync, '-p', config.port]);
        if (config.pipe) {
            p.stderr.pipe(process_1.default.stderr);
            p.stdout.pipe(process_1.default.stdout);
        }
        var ready = false;
        setTimeout(() => {
            if (!ready) {
                p.kill();
            } // kill if fails to start
        }, 2000);
        p.stderr.on('data', chunk => {
            let chunkStr = chunk.toString();
            if (/database system is ready to accept connections/.test(chunkStr)) {
                success();
            }
            if (/ERROR/.test(chunkStr)) {
                console.error(`[PG ERROR]`, chunkStr);
            }
        });
        p.on('close', (code) => {
            if (!ready) {
                reject(new Error('Failed to start postgresql database'));
            }
            else {
                console.log('Closing postgresql server');
            }
        });
        function success() {
            ready = true;
            resolve(p);
        }
    });
}
function ensureInitDb(pgdata) {
    if (!fs_1.default.existsSync(path_1.default.join(pgdata, 'PG_VERSION'))) {
        return call(bin.initdb, ['-D', pgdata, '--nosync']).then(() => true);
    }
    else {
        return Promise.resolve(false);
    }
}
function runInitSql(config) {
    return __awaiter(this, void 0, void 0, function* () {
        var p = Promise.resolve();
        for (var sql of config.initSql) {
            yield call(bin.psql, ['-p', config.port, '-h', '127.0.0.1', '-d', 'postgres', '-c', sql]);
        }
    });
}
function call(command, args) {
    return new Promise((resolve, reject) => {
        var p = child_process_1.default.spawn(command, args);
        let out = '';
        p.stderr.on('data', chunk => out += chunk.toString());
        p.stderr.on('data', chunk => out += chunk.toString());
        p.on('close', (code) => {
            if (code > 0) {
                reject(new Error(`Process exit code: ${code}:\n\n${out}`));
            }
            else {
                resolve();
            }
        });
    });
}
exports.default = start;
if (require.main == module) {
    start({ pipe: true }).then(pg_proc => {
        pg_proc.on('close', () => {
            process_1.default.exit();
        });
        process_1.default.on('SIGINT', () => {
            pg_proc.kill('SIGINT');
        });
    });
}
